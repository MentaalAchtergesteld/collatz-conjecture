const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const COLORS = {};
COLORS.BACKGROUND = "hsl(0, 0%, 15%)";
COLORS.NODE_FILL = "hsl(45, 90%, 60%)";
COLORS.NODE_STROKE = "hsl(40, 80%, 60%)";
COLORS.NODE_CONNECTION = "hsl(45, 90%, 90%)";
COLORS.NODE_TEXT = "hsl(0, 0%, 15%)";

const NODE_RADIUS = 16;
const REPULSION_RADIUS = 256;
const REPULSION_FORCE = 8.0;

const SPRING_LENGTH = 120;
const SPRING_FORCE = 0.05;
const CENTER_GRAVITY = 0.01;
const MAX_VEL = 100;

let CENTER_X = canvas.width / 2;
let CENTER_Y = canvas.height / 2;

function lerp(start, end, t) {
	return start + (end - start) * t;
}

function posToArr(pos) { return [pos.x, pos.y] } 

function randomPosition() {
	return {
		x: Math.random() * canvas.width,
		y: Math.random() * canvas.height
	}
}

function magnitude(x, y) {
	return Math.sqrt(x*x + y*y);
}

function distance(x1, y1, x2, y2) {
	let deltaX = x1 - x2;
	let deltaY = y1 - y2;

	return magnitude(deltaX, deltaY);
}

function normalize(x, y) {
	let mag = magnitude(x, y);

	return { x: x/mag, y: y/mag };
}

class Node {
	constructor(value, x, y, radius) {
		this.value = value;

		this.x = x;
		this.y = y;
		this.velX = 0;
		this.velY = 0;

		this.maxRadius = radius;
		this.radius = 0;

		this.hue = this.value % 360;

		this.connections = [];
	}

	drawConnections(ctx) {
		for (let node of this.connections) {
			ctx.strokeStyle = COLORS.NODE_CONNECTION;
			ctx.lineWidth = 6;

			ctx.beginPath();
			ctx.moveTo(this.x, this.y);
			ctx.lineTo(node.x, node.y);
			ctx.stroke();
		}
	}

	draw(ctx) {
		ctx.fillStyle = `hsl(${this.hue}, 90%, 80%)`;
		ctx.strokeStyle = `hsl(${this.hue}, 80%, 70%)`;
		ctx.lineWidth = 4;

		ctx.beginPath();
		ctx.ellipse(
			this.x, this.y,
			this.radius, this.radius,
			0, 0,
			2*Math.PI
		);
		ctx.fill();
		ctx.stroke();

		const baseFontSize = 14;
		const maxTextWidth = this.radius*1.6;
		ctx.font = `${baseFontSize}px Arial`;

		const textString = String(this.value);
		const textWidth = ctx.measureText(textString).width;

		if (textWidth > maxTextWidth) {
			const scaleFactor = maxTextWidth / textWidth;
			const newFontSize = Math.floor(baseFontSize * scaleFactor);
			ctx.font = `${newFontSize}px Arial`;
		}

		ctx.fillStyle = COLORS.NODE_TEXT;
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';

		ctx.fillText(this.value, this.x, this.y);
	}

	updateRadius(delta) {
		if (this.radius == this.maxRadius) return;
		this.radius = lerp(this.radius, this.maxRadius, 10*delta);
		if (this.maxRadius - this.radius < 0.1) this.radius = this.maxRadius;
	}

	updateNodeRepulsion(nodes) {
		for (let node of Object.values(nodes)) {
			if (node == this) continue;

			let dist = distance(this.x, this.y, node.x, node.y);
			if (dist == 0) dist = 0.1;

			if (dist > REPULSION_RADIUS) continue;
			let deltaX = this.x - node.x;
			let deltaY = this.y - node.y;
			let [normX, normY] = posToArr(normalize(deltaX, deltaY));

			let force = (1 - (dist / REPULSION_RADIUS)) * REPULSION_FORCE;

			this.velX += normX * force;
			this.velY += normY * force;
		}
	}

	updateNodeAttraction() {
		for (let node of Object.values(this.connections)) {
			let dist = distance(this.x, this.y, node.x, node.y);
			if (dist == 0) dist = 0.1;

			let stretch = dist - SPRING_LENGTH;
			let deltaX = node.x - this.x;
			let deltaY = node.y - this.y;

			let [normX, normY] = posToArr(normalize(deltaX, deltaY));

			let force = stretch * SPRING_FORCE;

			this.velX += normX * force;
			this.velY += normY * force;
		}	
	}

	updateCenterGravity() {
		let centerDirX = CENTER_X - this.x;
		let centerDirY = CENTER_Y - this.y;

		this.velX  += centerDirX * CENTER_GRAVITY;
		this.velY  += centerDirY * CENTER_GRAVITY;
	}

	updateFriction() {
		this.velX *= 0.9;
		this.velY *= 0.9;
	}

	capVelocity() {
		if (magnitude(this.velX, this.velY) < MAX_VEL) return;
		let [normVelX, normVelY] = posToArr(normalize(this.velX, this.velY));
		this.velX = normVelX * MAX_VEL;
		this.velY = normVelY * MAX_VEL;
	}

	updatePosition(delta) {
		this.x += this.velX * delta;
		this.y += this.velY * delta;
	}

	update(delta, nodes) {
		this.updateRadius(delta);
		this.updateNodeRepulsion(nodes);
		this.updateNodeAttraction();
		this.updateCenterGravity();
		this.updateFriction();
		this.capVelocity();
		this.updatePosition(delta);
	}

	hasConnection(other) {
		return this.connections.includes(other);
	}

	connect(other) {
		if (!this.hasConnection(other)) this.connections.push(other);
		other.connect(this);
	}
}

function makeCanvasFullscreen() {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;

	CENTER_X = canvas.width / 2;
	CENTER_Y = canvas.height / 2;
}

function clearCanvas() {
	ctx.fillStyle = COLORS.BACKGROUND;
	ctx.fillRect(0, 0, canvas.width, canvas.height);
}

makeCanvasFullscreen();
clearCanvas();
window.addEventListener("resize", makeCanvasFullscreen);

class Collatz {
	constructor(start, x, y, initialDelay = 0.5) {
		this.start = start;
		this.current = start;
		this.timer = 0;
		this.delay = initialDelay;
		this.minDelay = 0.02;

		if (!nodes[String(this.start)]) addNode(this.start, x, y);
	}

	update(delta) {
		this.timer += delta;
		if (this.timer < this.delay) return;
		this.timer -= this.delay;

		let nextVal;
		if (this.current % 2 == 0) {
			nextVal = this.current / 2;
		} else {
			nextVal = this.current * 3 + 1;
		}

		let prevId = String(this.current);
		if (nodes[prevId].connections.includes(nextVal)) return;

		let nextId = String(nextVal);
		if (!nodes[nextVal]) {
			let prevNode = nodes[prevId];
			let x = prevNode.x + (Math.random()-0.5) * 40;
			let y = prevNode.y + (Math.random()-0.5) * 40;
			addNode(nextId, x, y);
		}

		connectNodes(prevId, nextId);
		this.current = nextVal;
		this.delay = Math.max(this.minDelay, this.delay*0.95);
	}
}


let lastTime = performance.now();
function loop(time) {
	let delta = Math.max((time - lastTime) / 1000, 0);
	lastTime = time;

	clearCanvas();

	nodes.forEach(n => n.update(delta, nodes));
	nodes.forEach(n => n.drawConnections(ctx));
	nodes.forEach(n => n.draw(ctx));

	requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
